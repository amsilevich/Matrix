# ﻿ФПМИ МФТИ, весна 2020
# ООП 1 курс, продвинутый поток.

# Задача 1. Матрицы над произвольным полем.
В этой задаче вам предлагается научиться пользоваться шаблонами с числовыми параметрами и вычислять с их помощью некоторые простые вещи на этапе компиляции. Запрещено пользоваться для этого специальными средствами С++11 и С++14, такими, как constexpr и static_assert. Кроме того, запрещено пользоваться инструментами из заголовочного файла <type_traits>. Если какие-то из этих средств или инструментов вам понадобятся, вы можете реализовать их аналоги самостоятельно.


# Часть 1.
Написать шаблонный класс Finite<unsigned N>, реализующий кольцо вычетов по модулю N. Требования:
* Должны поддерживаться операции сложения, вычитания, умножения.
* Должна поддерживаться операция возведения в натуральную степень k, причем это должно работать за полиномиальное время от log k.
* Если N простое, то должны быть определены операции взятия обратного элемента и деления по модулю, причем обе должны работать за полиномиальное время от log N. Если N не простое, то вызовы этих методов не должны компилироваться.

# Часть 2.
Используя ранее написанный класс рациональных чисел, написать класс Matrix с тремя шаблонными параметрами: unsigned M, unsigned N, typename Field=Rational. (По умолчанию берётся поле рациональных чисел, но можно создать матрицу и над конечным полем.)
* Попытка создать матрицу над Finite<N>, где N не простое, должна приводить к ошибке компиляции.
* Матрицы должны поддерживать следующие операции:
* Сложение, вычитание, операторы +=, -=. Сложение и вычитание матриц несоответствующих размеров не должно компилироваться.
* Умножение на число типа Field.
* Умножение двух матриц, работающее за o-малое от max(M,N)^3 (см. напр. алгоритм Штрассена). Попытка перемножить матрицы несоответствующих размеров должна приводить к ошибке компиляции.
* Метод det(), возвращающий определитель матрицы за O(N^3). Взятие определителя матрицы, у которой M != N, не должно компилироваться.
* Метод transposed(), возвращающий транспонированную матрицу.
* Метод rank() - вычислить ранг матрицы.
* Методы inverted() и invert() - вернуть обратную матрицу и обратить данную матрицу. Попытка обратить матрицу, у которой M != N, должна приводить к ошибке компиляции.
* Метод trace() - вычислить след матрицы. Вычисление следа от неквадратной матрицы не должно компилироваться.
* Методы getRow(unsigned) и getColumn(unsigned), возвращающие std::vector<Field> из соответствующих значений.
* К матрице должен быть дважды применим оператор [], причём это должно работать как для неконстантных, так и для константных матриц. В первом случае содержимое матрицы должно быть можно таким способом поменять.
* Другие способы изменения содержимого матрицы, кроме описанных выше, должны отсутствовать. Однако не запрещается реализовать дополнительные методы для выполнения каких-либо иных алгебраических операций или для удобства работы, если по названию и сигнатуре этих методов будет без комментариев понятно их действие.
* Квадратные матрицы размера N должно быть можно объявлять всего с одним обязательным шаблонным параметром: SquareMatrix<N>.




